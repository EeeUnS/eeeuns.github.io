---
layout: post
title:  "Rust"
date:   2021-01-11 02:26:01 +0900
tag: etc
---

# Rust 정리

[site](https://rinthel.github.io/rust-lang-book-ko/foreword.html)


```rust
fn main()
{
    println!("Hello, world!");
}
```

```
$ rustc main.rs
$ ./main
```

프로젝트 생성, 빌드
--bin  바이너리용 프로젝트
```
$ cargo new hello_cargo --bin
$ cd hello_cargo
$ cargo build
$ cargo run
$ cargo check
$cargo build --release
```

- let : 변수생성
- mut - mutable
- // : 주석
- String  UTF-8 문자열 타입

read_line : 값반환 io::Result
- Result : 열거형
- Result의 expect 메소드
  - Err : 작동멈춤 인자메시지 출력
  - Ok 결괏값 돌려줌 : 입력받은 바이트
  - 호출안할시 경고

println
- {} : 변경자 값이표시되는 위치

###  crate 사용

러스트 코드의 묶음

```
Filename: Cargo.toml
[dependencies]

rand = "0.3.14"
```

Cargo.lock : build시 생성
- 모든 의존 패키지 버전 기록

크레이트 업데이트 cargo update

rand::thread_rng : 현재 스레드에서만 사용되는 특별한 정수생성기



cargo doc --open : 사용한 모든 의존 패키지 제공 문서들을 빌드해서 브라우저에 표시

비교
```
match guess.cmp(&secret_number) {
    Ordering::Less    => println!("Too small!"),
    Ordering::Greater => println!("Too big!"),
    Ordering::Equal   => println!("You win!"),
}
```
std::cmp::Ordering
- Less
- Greater
- Equal

변수 타입변경가능
```
let guess: u32 = guess.trim().parse().expect("Please type a number!");
```
- trim : 처음과 끝 빈칸 제거(\n..)
- parese : 문자열을 숫자형으로 파싱 타입명시 
- u32
- i32
- i64


```
loop 
{ break; continue;}
```
무한루프

- 변수선언 let
- 상수선언 const MAX_POINTS: u32 = 100_000모든 단어 대문자


## shadowing
let을 통해 덮어쓰기 가능 

```rust
fn main() {
    let x = 5;

    let x = x + 1;

    let x = x * 2;

    println!("The value of x is: {}", x);
}
```
다음과같은 응용가능
```rust
let spaces = "   ";
let spaces = spaces.len();
```

## 타입

- signed : i 8/16/32/64
- unsigned : u 8/16/32/64
- arch : isize usize 
i/usize :아키텍처에 따라다름 32bit아키텍처 -32 


정수형 리터럴

- 10진수 :98_222
- 16진수 0xff
- 8진수 : 0o77
- 2진수 0b1111_0000
- byte : b'A'

부동소수점
- f32/64

타입명시
```rust
let x: f32 = 3.0
```

- bool true false
- char Unicode Scalar


tuple

```rust
fn main() {
    let tup = (500, 6.4, 1);

    let (x, y, z) = tup;

    println!("The value of y is: {}", y);
  
    let five_hundred = x.0;

    let six_point_four = x.1;

    let one = x.2;
}
```

배열
```rust
fn main() {
    let a = [1, 2, 3, 4, 5];
  let months = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];

    let first = a[0];
    let second = a[1];
}
```
배열길이를 넘어 접근할시 실행중 에러


# 함수

위치 신경안씀

```rust
fn main() {
    println!("Hello, world!");

    another_function();
}

fn another_function() {
    println!("Another function.");
}
```

매개변수
```rust
fn another_function(x: i32, y: i32) {
    println!("The value of x is: {}", x);
    println!("The value of y is: {}", y);
}
```

# 구문/표현식

다음은 불가능 let은 구문이며 반환값이 없음 c와 차이
```rust
fn main() {
    let x = (let y = 6);
}
```

{}은 표현식
```rust
fn main() {
    let x = 5;
    let y = {
        let x = 3;
        x + 1
    };
    println!("The value of y is: {}", y);
}
```
{}은 4를 반환 세미콜론없음

반환값
return을 통해 일찍 반환할수있으나 암묵적으로 마지막 표현식을 반환 세미콜론x
```rust
fn plus_one(x: i32) -> i32 {
    x + 1
}
```
세미콜론 붙을시 구문은 값을 산출하지 않기에 ()처럼 비어있는 튜플로 표현 따라서 mismatched types에러가 남.


# 제어문

## if

```rust
fn main() {
    let number = 6;
    if number % 4 == 0 {
        println!("number is divisible by 4");
    } else if number % 3 == 0 {
        println!("number is divisible by 3");
    } else if number % 2 == 0 {
        println!("number is divisible by 2");
    } else {
        println!("number is not divisible by 4, 3, or 2");
    }
}

```
반드시 bool이어야함

다음의 응용이 가능
```rust
fn main() {
    let condition = true;
    let number = if condition {
        5
    } else {
        6
    };

    println!("The value of number is: {}", number);
}
```
각 {}의 반환은 확실하게 타입이 일치해야함. 안그럼 컴파일 에러.

```rust
fn main() {
    let condition = true;

    let number = if condition {
        5
    } else {
        "six"
    };

    println!("The value of number is: {}", number);
}
```
타입이 일치하지않으므로 에러


# 반복문

## loop
무한루프

## while

```rust
fn main() {
    let mut number = 3;

    while number != 0 {
        println!("{}!", number);

        number = number - 1;
    }

    println!("LIFTOFF!!!");
}
```


```rust
fn main() {
    let a = [10, 20, 30, 40, 50];

    for element in a.iter() {
        println!("the value is: {}", element);
    }
}
```


```rust
fn main() {
    for number in (1..4).rev() {
        println!("{}!", number);
    }
    println!("LIFTOFF!!!");
}
```


# 소유권

## 소유권 규칙
1. 러스트의 각각의 값은 해당값의 오너(owner)라고 불리우는 변수를 갖고 있다.
2. 한번에 딱 하나의 오너만 존재할 수 있다.
3. 오너가 스코프 밖으로 벗어나는 때, 값은 버려진다(dropped).

```rust
let mut s = String::from("hello");

s.push_str(", world!"); // push_str()은 해당 스트링 리터럴을 스트링에 붙여줍니다.

println!("{}", s); // 이 부분이 `hello, world!`를 출력할 겁니다.
```
s가 스코프를 벗어날때 rust는 drop 함수를 호출

## move 

```
let s1 = String::from("hello");
let s2 = s1;
println!("{}, world!", s1);
```
복사에 대해서 러스트는 s1을 더이상 유효하지않은 참조자라 판단 따라서 에러
러스트는 자동으로 깊은 복사를 하지않음.

## clone

깊은 복사
```rust
let s1 = String::from("hello");
let s2 = s1.clone();
println!("s1 = {}, s2 = {}", s1, s2);
```

스택에 저장할수잇는 타입에 대해서 Copy 트레잇이라고 하는 annotation이 있다. Copy 트레잇이 있으면 대입 후에 예전 변수를 사용 할 수 있다. Drop 트레잇이 구현되었다면 Copy 트레잇을 어노테이션 할 수 없음. 둘은 양립 불가능. 컴파일 에러

- u32와 같은 모든 정수형 타입들
- true와 false값을 갖는 부울린 타입 bool
- f64와 같은 모든 부동 소수점 타입들
- Copy가 가능한 타입만으로 구성된 튜플들. (i32, i32)는 Copy가 되지만, (i32, String)은 안됩니다.


소유권을 함수 매개변수로 넘기면 함수를 탈출하면서 메모리가 해제된다.
```rust
fn main() {
    let s = String::from("hello");  // s가 스코프 안으로 들어왔습니다.
    takes_ownership(s);             // s의 값이 함수 안으로 이동했습니다...
                                    // ... 그리고 이제 더이상 유효하지 않습니다.
    let x = 5;                      // x가 스코프 안으로 들어왔습니다.

    makes_copy(x);                  // x가 함수 안으로 이동했습니다만,
                                    // i32는 Copy가 되므로, x를 이후에 계속
                                    // 사용해도 됩니다.
} // 여기서 x는 스코프 밖으로 나가고, s도 그 후 나갑니다. 하지만 s는 이미 이동되었으므로,
  // 별다른 일이 발생하지 않습니다.
fn takes_ownership(some_string: String) { // some_string이 스코프 안으로 들어왔습니다.
    println!("{}", some_string);
} // 여기서 some_string이 스코프 밖으로 벗어났고 `drop`이 호출됩니다. 메모리는
  // 해제되었습니다.
fn makes_copy(some_integer: i32) { // some_integer이 스코프 안으로 들어왔습니다.
    println!("{}", some_integer);
} // 여기서 some_integer가 스코프 밖으로 벗어났습니다. 별다른 일은 발생하지 않습니다.
```

```rust
fn main() {
    let s1 = gives_ownership();         // gives_ownership은 반환값을 s1에게
                                        // 이동시킵니다.

    let s2 = String::from("hello");     // s2가 스코프 안에 들어왔습니다.

    let s3 = takes_and_gives_back(s2);  // s2는 takes_and_gives_back 안으로
                                        // 이동되었고, 이 함수가 반환값을 s3으로도
                                        // 이동시켰습니다.
} // 여기서 s3는 스코프 밖으로 벗어났으며 drop이 호출됩니다. s2는 스코프 밖으로
  // 벗어났지만 이동되었으므로 아무 일도 일어나지 않습니다. s1은 스코프 밖으로
  // 벗어나서 drop이 호출됩니다.
fn gives_ownership() -> String {             // gives_ownership 함수가 반환 값을
                                             // 호출한 쪽으로 이동시킵니다.

    let some_string = String::from("hello"); // some_string이 스코프 안에 들어왔습니다.

    some_string                              // some_string이 반환되고, 호출한 쪽의
                                             // 함수로 이동됩니다.
}
// takes_and_gives_back 함수는 String을 하나 받아서 다른 하나를 반환합니다.
fn takes_and_gives_back(a_string: String) -> String { // a_string이 스코프
                                                      // 안으로 들어왔습니다.

    a_string  // a_string은 반환되고, 호출한 쪽의 함수로 이동됩니다.
}
```
s1,s3은 main을 벗어나면서 drop호출 s2는 s3로 이동해서 애초에 없음.


```rust
fn main() {
    let s1 = String::from("hello");

    let (s2, len) = calculate_length(s1);

    println!("The length of '{}' is {}.", s2, len);
}

fn calculate_length(s: String) -> (String, usize) {
    let length = s.len(); // len()함수는 문자열의 길이를 반환합니다.

    (s, length)
}
```
튜플을 사용해 값을 다시 돌려받을 수 있음


## 참조자references 빌림 borrowing

```rust
fn calculate_length(s: &String) -> usize {
    s.len()
}
```


가변 참조

```rust
fn main() {
    let mut s = String::from("hello");
    change(&mut s);
}
fn change(some_string: &mut String) {
    some_string.push_str(", world");
}
```
가변 참조자는 특정한 스코프 내에 가변 참조자를 딱 하나만 만들 수 있다.

다음은 불가능
```rust
let mut s = String::from("hello");
let r1 = &mut s;
let r2 = &mut s;
```
Data race 방지.


data race는 다음중에서 일어난다.

1. 두 개 이상의 포인터가 동시에 같은 데이터에 접근한다.
2. 그 중 적어도 하나의 포인터가 데이터를 쓴다.
3. 데이터에 접근하는데 동기화를 하는 어떠한 메커니즘도 없다.

불변참조자를 가지고 있을때도 컴파일 에러

```rust
let mut s = String::from("hello");
let r1 = &s; // 문제 없음
let r2 = &s; // 문제 없음
let r3 = &mut s; // 큰 문제
```

참조자는 항상 유효해야한다.
다음은 불가
```rust
fn dangle() -> &String { // dangle은 String의 참조자를 반환합니다

    let s = String::from("hello"); // s는 새로운 String입니다

    &s // 우리는 String s의 참조자를 반환합니다.
} // 여기서 s는 스코프를 벗어나고 버려집니다. 이것의 메모리는 사라집니다.
  // 위험하군요!
```


```rust
fn first_word(s: &String) -> usize {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return i;
        }
    }

    s.len()
}
```
이러한 값은 string 내부가 바뀌었을때 저장되어있는 결괏값은 의미가 없어진다 이를 방지하기위해.


## 스트링 슬라이스
```rust
let s = String::from("hello world");
let hello = &s[0..5]; // &s[..5];
let world = &s[6..11]; // &s[6..];   &s[..]
```
스트링 슬라이스 타입 &str

```rust
fn first_word(s: &String) -> &str {
    let bytes = s.as_bytes();
    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &s[0..i];
        }
    }

    &s[..]
}
```

```rust
fn main() {
    let mut s = String::from("hello world");

    let word = first_word(&s);

    s.clear(); // Error!

    println!("the first word is: {}", word);
}
```

# 구조체


```rust
struct User {
    username: String,
    email: String,
    sign_in_count: u64,
    active: bool,
}


//in function
let user1 = User {
    email: String::from("someone@example.com"),
    username: String::from("someusername123"),
    active: true,
    sign_in_count: 1,
};
///

fn build_user(email: String, username: String) -> User {
    User {
        email: email,
        username: username,
        active: true,
        sign_in_count: 1,
    }
}

fn build_user(email: String, username: String) -> User {
    User {
        email,
        username,
        active: true,
        sign_in_count: 1,
    }
}
//다음도 허용

```

```rust
let user2 = User {
    email: String::from("another@example.com"),
    username: String::from("anotherusername567"),
    ..user1
};
```
나머지는 user1을 재사용

## 튜플 구조체

```rust
struct Color(i32, i32, i32);
struct Point(i32, i32, i32);

let black = Color(0, 0, 0);
let origin = Point(0, 0, 0);
```

유사 유닛 구조체(unit-like structs)
어떤 필드도 없는 구조체


```
struct User {
    username: &str,
    email: &str,
    sign_in_count: u64,
    active: bool,
}
fn main() {
    let user1 = User {
        email: "someone@example.com",
        username: "someusername123",
        active: true,
        sign_in_count: 1,
    };
}
```
다음은 라이프타임을 명시하라고 에러가 난다.

메소드 정의
```rust
#[derive(Debug)]
struct Rectangle {
    length: u32,
    width: u32,
}
impl Rectangle {
    fn area(&self) -> u32 {
        self.length * self.width
    }

    fn can_hold(&self, other: &Rectangle) -> bool {
        self.length > other.length && self.width > other.width
    }
    fn square(size: u32) -> Rectangle {
        Rectangle { length: size, width: size }
    }

}
fn main() {
    let rect1 = Rectangle { length: 50, width: 30 };
    let rect2 = Rectangle { length: 40, width: 10 };
    let rect3 = Rectangle { length: 45, width: 60 };

    println!("Can rect1 hold rect2? {}", rect1.can_hold(&rect2));
    println!("Can rect1 hold rect3? {}", rect1.can_hold(&rect3));

    println!(
        "The area of the rectangle is {} square pixels.",
        rect1.area()
    );
    let sq = Rectangle::square(3);
}
```

러스트는 화살표 연산자가 없다.
자동 참조 및 역참조(automatic referencing and dereferencing) 를 가지고있다

## enum 

```rust
enum IpAddrKind {
    V4,
    V6,
}
struct IpAddr {
    kind: IpAddrKind,
    address: String,
}
let home = IpAddr {
    kind: IpAddrKind::V4,
    address: String::from("127.0.0.1"),
};
let loopback = IpAddr {
    kind: IpAddrKind::V6,
    address: String::from("::1"),
};
```
다음을 개선하여
이렇게 사용가능

```rust
enum IpAddr {
    V4(String),
    V6(String),
}
let home = IpAddr::V4(String::from("127.0.0.1"));
let loopback = IpAddr::V6(String::from("::1"));
//다음과 같이도 가능
enum IpAddr {
    V4(u8, u8, u8, u8),
    V6(String),
}
let home = IpAddr::V4(127, 0, 0, 1);

enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
```
참고로 ip주소 저장에 관해서는 [표준라이브러리](https://doc.rust-lang.org/std/net/enum.IpAddr.html)가 존재

```rust
impl Message {
    fn call(&self) {
        // 메소드 내용은 여기 정의할 수 있습니다.
    }
}

let m = Message::Write(String::from("hello"));
m.call();
```

# Option 열거형

```rust
enum Option<T> {
    Some(T),
    None,
}

let some_number = Some(5);
let some_string = Some("a string");
let absent_number: Option<i32> = None;
```
Option\<T> 와 T 는 다른 타입이며 둘을 섞어서 더하거나 하지못함.

## match


```rust
enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn value_in_cents(coin: Coin) -> u32 {
    match coin {
        Coin::Penny => {
            println!("Lucky penny!");
            1
        },
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter => 25,
    }
}
```


Option\<T>응용


```rust
fn plus_one(x: Option<i32>) -> Option<i32> {
    match x {
        None => None,
        Some(i) => Some(i + 1),
    }
}
let five = Some(5);
let six = plus_one(five);
let none = plus_one(None);

let some_u8_value = 0u8;
match some_u8_value {
    1 => println!("one"),
    3 => println!("three"),
    5 => println!("five"),
    7 => println!("seven"),
    _ => (),
}

```
만약 None과 Some중에 하나가 빠질시엔 에러 _ 사용


## if let

하나의 패턴만 매칭 시키고 나머지 경우는 무시


다음은 같은 행동
```rust
let mut count = 0;

match coin {
    Coin::Quarter(state) => println!("State quarter from {:?}!", state),
    _ => count += 1,
}

if let Coin::Quarter(state) = coin {
    println!("State quarter from {:?}!", state);
} else {
    count += 1;
}
```

```rust

```




























