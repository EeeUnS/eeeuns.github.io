---
layout: post
title: "pure  call error"
date:   2023-04-15 19:26:01 +0900
tag: note
---

pure  call error 라는걸 주워들었다. 

그게뭐지?하고 찾아보게 된 글 

코드는 여기 참고

[https://iamskylover.tistory.com/90](https://iamskylover.tistory.com/90)

해당 코드를 실행하면 pure call error 가 나는걸 알 수 있는데 

![Untitled](/images/purecall/Untitled.png)

일반적인 호출

![Untitled](/images/purecall/Untitled%201.png)

A 소멸자에서의 호출

![Untitled](/images/purecall/Untitled%202.png)

보면 virtual table이 가르키는 주소가체가 다르다

해당 코드를 조금더 들여다보면 rcx 에 B의 vftable 값을 씌운다

![Untitled](/images/purecall/Untitled%203.png)

A class 소멸자에서도 a의 vftable 주소를 가르키게 세팅한다는것을 알 수 있다.

![Untitled](/images/purecall/Untitled%204.png)

그래서 생각할 수 있는게 

class a의 생성자, 소멸자에서는 class a의 가상 함수만 호출을 한다.

![Untitled](/images/purecall/Untitled%205.png)

A class의 순수가상함수는 purecall이라는 곳을 가르킨다

release 에서도 해당방식으로 작동한다.

![Untitled](/images/purecall/Untitled%206.png)

그래서 든생각

A → B → C 식으로 상속해서

각각의 상속받는 함수를 만들면 소멸자에서 각각 클래스에 해당하는 함수를 호출 할 수도 있겠구나.

A 소멸자에서 호출하는건 뿌서지니 빼고 B를 상속받는 C클래스를 추가로 만들어서 테스트 해봤다.

![Untitled](/images/purecall/Untitled%207.png)

생각한대로 작동한다. 뭔가 연쇄 책임 패턴을 보는거같기도..

사실 딱 기억할거는 한가지다.

생성자 소멸자에서 구현되지않은 순수가상함수를 호출하면 안된다.

사실 한번 겪어보면 알게 될 얘기기도 하지만..