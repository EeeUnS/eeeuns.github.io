---
layout: post
title:  "전방선언 : 컴파일러가 필요한 정보"
date:   2025-10-01 19:26:01 +0900
tag: cpp
---

https://eeeuns.github.io/2024/08/09/understandingcomputercompileo/
https://eeeuns.github.io/2024/09/03/reducebuild/

이 중 전방선언에 대해 좀 이모저모 얘기를 하고자한다.


**개별 cpp파일을 컴파일을 할때**, 정보가 없는 심볼을 사용한다면, 당연히 컴파일러는 이 심볼에 대한 정보를 모르니 에러를 낸다.
컴파일시, 심볼에 대한 정보 부재는 컴파일 에러를 낸다. 


링킹단에서 해당 심볼의 상세 정보가 없을때 링킹에러를 낼지라도, 
컴파일단에서 개별 파일별로 해당 심볼이 유효하다는 정보(이 심볼은 다른 파일에 있어란 정보까지)는 완전하다.

전방 선언은 이때, **이때 작성자는 ㅇㅇ 나 이거 알고 있음. 근데 다른 파일에 있음 이라고 컴파일러에게 알려주는거다.**

그럼 컴파일러는 이 심볼이 존재함은 알지만, 이 파일을 컴파일하는데 상세 정보가 필요한게 아니라면 해당 파일을 정상적으로 컴파일한다.





전방선언은 보통 순환 include 참조를 겪을때 쓰는 해결책으로 처음 접하게 된다.
사실 컴파일 속도 최적화의 측면에서도 굉장히 중요한데,

헤더파일의 include 를 최대한 줄이고, 크기 자체를 줄이는게 중요하다.


작업을 하면서, 어떤 케이스에서 전방선언이 되고 안되는지 작업을 하다 보다보면,
컴파일러가 어떤 이유로 이 정보는 필요하고 이 정보가 불필요한지 알게되는데,
원리는 컴파일러 동작방식을 생각하면 쉽게 이해할 수 있으나, 후속적으로 정리해볼까한다.


말했다시피 전방선언은 말이 전방선언이지,
C언어 가장 처음배우는 선언과 정의에 나오는 그 선언이 맞다.

선언은 이 파일을 컴파일하는 컴파일러에게 정확한 정보를 알지 못하는 심볼에 대해 해당 심볼이 이후에 있다 or 다른 파일에 있다고 알리는 거다.
선언은 헤더파일의 존재의의 그 자체에 해당한다.

포인터는 항상항상항상 8byte다.
따라서 모든 자료형을 포인터로 다룬다면, 객체가 전방 선언으로 모두 사용이 가능하다.
pimple 패턴의 주요 아이디어이다.

header 안의 include를 제거할때, 전방선언으로 불가능한 것들이 있다.

Cpp를 컴파일할때 함수 주소 정보는 링킹단계에서 두고 마지막에 연결을 할 수 있다 그러나, 함수가 가지는 스택사이즈 들은 사실 컴파일단계에서 정해져야한다.
이는 곧 객체의 실제 size는 컴파일 단계에서 확정되어야함을 알 수 있다. (실제로 static_assert로 sizeof 비교를 하는건 굉장히 흔히 한다)

1. 상속 : 상속은 상속받는 객체의 size를 계산할때 필수정보이다. 따라서 전방선언으로는 객체 정보를 해당 파일 컴파일때 알 수 없기에 불가능하다.
2. composition : 이 또한 객체의 size를 계산할때 필수정보이다. 하지만 포인터로 다룬다면 가능하다.
3. template : 내부 구현체를 접근하는 경우, 객체 size, 함수들이 필수 정보이다.

포인터 멤버변수는 답이없지만 어쩔 수 없는 방안이지만,
컴파일의 관점에서만 보면 상속보다는 composition으로 하는게 좋다.


template의 구현 특성상 구현체가 헤더파일에 있어야함은 필수이다.
전방선언과 상성이 최악이며, 이로인해 헤더 파일 include를 많이 먹을 수 밖에없다.

사실 template은 타입을 포인터로 다룬다면 사실 컨테이너 같은 클래스들은 void*로 가능하면 다룬다면 충분히 가능한 경우도 있다.
이러면 template을 최대한 쓰지않을 수 있다.



음... 유니티빌드를 알아보자.




C#엔 partial class라는 똑똑한 기능이 있지만 구닥다리 cpp에는 그런게 있을리없다.

이런 구닥다리구조로 인한 다양한 몸비틀기 방법론이 나왔지만, 
사실 module 시스템을 사용하는 현대의 언어에는 모두 의미없는 기술일건데,

진정한 미래에 로스트 기술이 되지않을까 싶다.






